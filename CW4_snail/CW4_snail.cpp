#include <vector> 

using namespace std;

vector<int> snail(const vector<vector<int>>& snail_map) {
    // Объявление функции `snail`, принимающей двухмерный вектор (матрицу) и возвращающей вектор целых чисел.

    vector<int> result; // Вектор содержащий элементы в порядке прохождения по матрице.
    
    if (snail_map.empty() || snail_map[0].empty()) { // проверка является ли входная матрица пустой.
        return result; // возврат пустого вектора
    }
    int top = 0;// верхняя граница
    int bottom = snail_map.size() - 1; // нижняя граница(индекс последней строки)
    int left = 0; // левая граница
    int right = snail_map[0].size() - 1; //  правая граница (индекс последнего столбца).

    while (top <= bottom && left <= right) { // Цикл, который продолжается, пока все границы не пересекутся.
        
        // Проход по верхней границе слева направо
        for (int i = left; i <= right; ++i) { // Цикл для обхода верхней строки, начиная с левой границы до правой.
            result.push_back(snail_map[top][i]); // Добавление текущего элемента верхней границы в вектор.
            
        }
        ++top;// Сдвигаем верхнюю границу вниз, чтобы не обрабатывать эту строку повторно.

        // Проход по правой границе сверху вниз
        for (int i = top; i <= bottom; ++i) {
            // Цикл для обхода правого столбца, начиная с верхней границы до нижней.
            result.push_back(snail_map[i][right]);
            // Добавление текущего элемента правой границы в вектор `result`.
        }
        --right; // Сдвигаем правую границу влево, чтобы не обрабатывать этот столбец повторно.
        

        // Проход по нижней границе справа налево
        if (top <= bottom) {
            // Проверка, осталась ли нижняя граница для обработки.
            for (int i = right; i >= left; --i) {
                // Цикл для обхода нижней строки справа налево.
                result.push_back(snail_map[bottom][i]); // Добавление текущего элемента нижней границы в вектор `result`.
                
            }
            --bottom;// Сдвигаем нижнюю границу вверх, чтобы не обрабатывать эту строку повторно.
            
        }

        // Проход по левой границе снизу вверх, если она еще не обработана
        if (left <= right) {
            // Проверка, осталась ли левая граница для обработки.
            for (int i = bottom; i >= top; --i) {
                // Цикл для обхода левого столбца снизу вверх.
                result.push_back(snail_map[i][left]); // Добавление текущего элемента левой границы в вектор `result`.
                
            }
            ++left; // Сдвигаем левую границу вправо, чтобы не обрабатывать этот столбец повторно.
            
        }
    }
    return result;
    // Возврат элементов матрицы в порядке «улитки».
}